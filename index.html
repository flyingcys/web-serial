<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chrome ä¸²å£è°ƒè¯•åŠ©æ‰‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* ä¸²å£è¿æ¥æ§åˆ¶é¢æ¿æ ·å¼ */
        .connection-panel {
            background: linear-gradient(135deg, #8B7CF6, #A78BFA);
            border-radius: 12px;
            padding: 24px;
            color: white;
            box-shadow: 0 4px 12px rgba(139, 124, 246, 0.3);
        }

        .connection-panel h2 {
            margin-bottom: 20px;
            font-size: 18px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 8px;
            display: inline-block;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .config-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .config-item label {
            font-weight: 500;
            font-size: 14px;
        }

        .config-item select {
            padding: 10px 12px;
            border: none;
            border-radius: 6px;
            background: white;
            color: #333;
            font-size: 14px;
            cursor: pointer;
        }

        .connection-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: #3B82F6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563EB;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn-danger {
            background: #10B981;
            color: white;
        }

        .btn-danger:hover {
            background: #059669;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #EF4444;
        }

        .status-dot.connected {
            background: #10B981;
        }

        /* æ•°æ®æ¥æ”¶é¢æ¿æ ·å¼ */
        .receive-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .receive-panel h2 {
            color: #374151;
            margin-bottom: 16px;
            font-size: 16px;
            background: #F3F4F6;
            padding: 8px 16px;
            border-radius: 8px;
            display: inline-block;
        }

        .receive-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .receive-options {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .checkbox-group label {
            font-size: 14px;
            color: #374151;
        }

        .data-display {
            background: #1F2937;
            border-radius: 8px;
            padding: 16px;
            min-height: 300px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #D1D5DB;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .data-display::before {
            content: "ç­‰å¾…ä¸²å£æ•°æ®...";
            color: #6B7280;
            font-style: italic;
        }

        .data-display.has-data::before {
            display: none;
        }

        .stats-bar {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            padding: 8px 0;
            font-size: 12px;
            color: #6B7280;
            border-top: 1px solid #E5E7EB;
        }

        /* æ•°æ®å‘é€é¢æ¿æ ·å¼ */
        .send-panel {
            background: linear-gradient(135deg, #10B981, #34D399);
            border-radius: 12px;
            padding: 24px;
            color: white;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .send-panel h2 {
            margin-bottom: 20px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 8px;
            display: inline-block;
        }

        .send-options {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .send-mode-options {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .send-input {
            margin-bottom: 16px;
        }

        .send-input textarea {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            min-height: 100px;
            background: white;
            color: #333;
        }

        .send-input textarea::placeholder {
            color: #9CA3AF;
        }

        .quick-commands {
            margin-top: 16px;
        }

        .quick-commands h3 {
            font-size: 14px;
            margin-bottom: 8px;
            color: rgba(255, 255, 255, 0.9);
        }

        .quick-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .btn-quick {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-quick:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-manage {
            background: #F59E0B;
            color: white;
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-manage:hover {
            background: #D97706;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .config-grid {
                grid-template-columns: 1fr;
            }
            
            .connection-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .receive-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .send-options {
                flex-direction: column;
                align-items: stretch;
            }
        }

        /* é”™è¯¯æç¤ºæ ·å¼ */
        .error-message {
            background: #FEE2E2;
            color: #DC2626;
            padding: 12px;
            border-radius: 8px;
            margin: 16px 0;
            border-left: 4px solid #DC2626;
        }

        .success-message {
            background: #D1FAE5;
            color: #065F46;
            padding: 12px;
            border-radius: 8px;
            margin: 16px 0;
            border-left: 4px solid #10B981;
        }

        /* éšè—å…ƒç´  */
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ä¸²å£è¿æ¥æ§åˆ¶é¢æ¿ -->
        <div class="connection-panel">
            <h2>ä¸²å£è¿æ¥æ§åˆ¶</h2>
            
            <div class="config-grid">
                <div class="config-item">
                    <label for="baudRate">æ³¢ç‰¹ç‡:</label>
                    <select id="baudRate">
                        <option value="9600">9600</option>
                        <option value="19200">19200</option>
                        <option value="38400">38400</option>
                        <option value="57600">57600</option>
                        <option value="115200" selected>115200</option>
                        <option value="230400">230400</option>
                        <option value="460800">460800</option>
                        <option value="921600">921600</option>
                    </select>
                </div>
                
                <div class="config-item">
                    <label for="dataBits">æ•°æ®ä½:</label>
                    <select id="dataBits">
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="8" selected>8</option>
                    </select>
                </div>
                
                <div class="config-item">
                    <label for="stopBits">åœæ­¢ä½:</label>
                    <select id="stopBits">
                        <option value="1" selected>1</option>
                        <option value="2">2</option>
                    </select>
                </div>
                
                <div class="config-item">
                    <label for="parity">æ ¡éªŒä½:</label>
                    <select id="parity">
                        <option value="none" selected>æ— </option>
                        <option value="even">å¶æ ¡éªŒ</option>
                        <option value="odd">å¥‡æ ¡éªŒ</option>
                    </select>
                </div>
                
                <div class="config-item">
                    <label for="targetDevice">ç›®æ ‡è®¾å¤‡:</label>
                    <select id="targetDevice">
                        <option value="custom">è‡ªå®šä¹‰</option>
                    </select>
                </div>
            </div>
            
            <div class="connection-controls">
                <button id="connectBtn" class="btn btn-primary">ğŸ”— è¿æ¥ä¸²å£</button>
                <button id="disconnectBtn" class="btn btn-secondary" disabled>æ–­å¼€è¿æ¥</button>
                <div class="status-indicator">
                    <div id="statusDot" class="status-dot"></div>
                    <span id="statusText">æœªè¿æ¥</span>
                </div>
                <button id="troubleshootBtn" class="btn btn-danger">ğŸ”§ ä¸²å£æ•…éšœæ’é™¤</button>
            </div>
            
            <div id="errorMessage" class="error-message hidden"></div>
            <div id="successMessage" class="success-message hidden"></div>
        </div>

        <!-- æ•°æ®æ¥æ”¶é¢æ¿ -->
        <div class="receive-panel">
            <h2>æ¥æ”¶æ•°æ®</h2>
            
            <div class="receive-controls">
                <div class="receive-options">
                    <button id="clearDataBtn" class="btn btn-secondary">æ¸…ç©ºæ—¥å¿—</button>
                    <button id="saveDataBtn" class="btn btn-secondary">ä¿å­˜æ—¥å¿—</button>
                    <button id="pauseReceiveBtn" class="btn btn-secondary">â¸ï¸ æš‚åœæ¥æ”¶</button>
                    <div class="checkbox-group">
                        <input type="checkbox" id="receiveHexMode">
                        <label for="receiveHexMode">HEXæ˜¾ç¤º</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showTimestamp" checked>
                        <label for="showTimestamp">æ˜¾ç¤ºæ—¶é—´æˆ³</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="autoScroll" checked>
                        <label for="autoScroll">è‡ªåŠ¨æ»šåŠ¨</label>
                    </div>
                    <button id="settingsBtn" class="btn btn-secondary">âš™ï¸</button>
                </div>
                <div class="receive-search">
                    <input type="text" id="searchFilter" placeholder="æ•°æ®è¿‡æ»¤/æœç´¢..." style="padding: 6px 12px; border: 1px solid #D1D5DB; border-radius: 6px; font-size: 14px;">
                </div>
            </div>
            
            <div id="dataDisplay" class="data-display"></div>
            
            <div class="stats-bar">
                <span>æ¥æ”¶: <span id="rxBytes">0</span> å­—èŠ‚</span>
                <span>å‘é€: <span id="txBytes">0</span> å­—èŠ‚</span>
                <span>é€Ÿç‡: <span id="commSpeed">0</span> B/s</span>
                <span>é”™è¯¯: <span id="errorCount">0</span></span>
                <span>ç¼“å†²: <span id="bufferCount">0</span>/<span id="maxBuffer">10000</span></span>
            </div>
        </div>

        <!-- æ•°æ®å‘é€é¢æ¿ -->
        <div class="send-panel">
            <h2>å‘é€æ•°æ®</h2>
            
            <div class="send-options">
                <div class="send-mode-options">
                    <div class="checkbox-group">
                        <input type="checkbox" id="hexMode">
                        <label for="hexMode">HEXæ¨¡å¼</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="addNewline" checked>
                        <label for="addNewline">æ·»åŠ æ¢è¡Œç¬¦</label>
                    </div>
                </div>
                <button id="sendBtn" class="btn btn-primary">ğŸ“¤ å‘é€</button>
            </div>
            
            <div class="send-input">
                <textarea id="sendData" placeholder="è¾“å…¥è¦å‘é€çš„æ•°æ®..."></textarea>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; font-size: 12px; color: rgba(255, 255, 255, 0.8);">
                    <span>å­—ç¬¦æ•°: <span id="charCount">0</span></span>
                    <div>
                        <label style="margin-right: 12px;">
                            <input type="checkbox" id="cyclicSend" style="margin-right: 4px;">
                            å¾ªç¯å‘é€
                        </label>
                        <label style="margin-right: 12px;">
                            é—´éš”: <input type="number" id="sendInterval" value="1000" min="100" max="60000" style="width: 60px; padding: 2px 4px; border: none; border-radius: 3px; margin-left: 4px;">ms
                        </label>
                        <button id="historyBtn" class="btn-quick">å†å²</button>
                    </div>
                </div>
            </div>
            
            <div class="quick-commands">
                <h3>å¿«æ·å‘é€:</h3>
                <div class="quick-buttons">
                    <button class="btn-quick" data-command="AT">AT</button>
                    <button class="btn-quick" data-command="AT+CSQ">AT+CSQ</button>
                    <button class="btn-quick" data-command="AT+CPIN?">AT+CPIN?</button>
                    <button class="btn-quick" data-command="AT+CGMI">AT+CGMI</button>
                    <button class="btn-manage">ç®¡ç†å‘½ä»¤</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let serialPort = null;
        let reader = null;
        let writer = null;
        let isConnected = false;
        let rxByteCount = 0;
        let txByteCount = 0;
        let availablePorts = [];
        let connectionStartTime = null;
        let isReceivePaused = false;
        let receiveBuffer = [];
        let maxBufferSize = 10000;
        let sendHistory = [];
        let maxHistorySize = 50;
        let cyclicSendTimer = null;
        let quickCommands = [
            { name: 'AT', command: 'AT' },
            { name: 'AT+CSQ', command: 'AT+CSQ' },
            { name: 'AT+CPIN?', command: 'AT+CPIN?' },
            { name: 'AT+CGMI', command: 'AT+CGMI' }
        ];
        let errorCount = 0;
        let communicationStartTime = null;
        let lastDataTime = null;

        // DOM å…ƒç´ 
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const errorMessage = document.getElementById('errorMessage');
        const successMessage = document.getElementById('successMessage');
        const dataDisplay = document.getElementById('dataDisplay');
        const sendBtn = document.getElementById('sendBtn');
        const sendData = document.getElementById('sendData');
        const hexMode = document.getElementById('hexMode');
        const addNewline = document.getElementById('addNewline');
        const showTimestamp = document.getElementById('showTimestamp');
        const autoScroll = document.getElementById('autoScroll');
        const clearDataBtn = document.getElementById('clearDataBtn');
        const saveDataBtn = document.getElementById('saveDataBtn');
        const pauseReceiveBtn = document.getElementById('pauseReceiveBtn');
        const receiveHexMode = document.getElementById('receiveHexMode');
        const searchFilter = document.getElementById('searchFilter');
        const charCount = document.getElementById('charCount');
        const cyclicSend = document.getElementById('cyclicSend');
        const sendInterval = document.getElementById('sendInterval');
        const historyBtn = document.getElementById('historyBtn');
        const rxBytesSpan = document.getElementById('rxBytes');
        const txBytesSpan = document.getElementById('txBytes');
        const commSpeedSpan = document.getElementById('commSpeed');
        const errorCountSpan = document.getElementById('errorCount');
        const bufferCountSpan = document.getElementById('bufferCount');
        const maxBufferSpan = document.getElementById('maxBuffer');

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            checkSerialSupport();
            setupEventListeners();
            checkExistingPorts();
            loadQuickCommands();
            initializeQuickCommands();
            loadSendHistory();
        });

        // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
        function checkSerialSupport() {
            if (!('serial' in navigator)) {
                showError('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIã€‚è¯·ä½¿ç”¨ Chrome 89+ æˆ– Edge 89+ æµè§ˆå™¨ã€‚');
                connectBtn.disabled = true;
            }
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            connectBtn.addEventListener('click', connectToSerial);
            disconnectBtn.addEventListener('click', disconnectFromSerial);
            sendBtn.addEventListener('click', sendSerialData);
            clearDataBtn.addEventListener('click', clearReceivedData);
            saveDataBtn.addEventListener('click', saveReceivedData);
            pauseReceiveBtn.addEventListener('click', toggleReceivePause);
            receiveHexMode.addEventListener('change', refreshDataDisplay);
            searchFilter.addEventListener('input', filterDisplayedData);
            document.getElementById('troubleshootBtn').addEventListener('click', showTroubleshootDialog);
            historyBtn.addEventListener('click', showSendHistory);
            cyclicSend.addEventListener('change', toggleCyclicSend);
            sendData.addEventListener('input', updateCharCount);
            
            // Enter é”®å‘é€
            sendData.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    sendSerialData();
                }
            });
        }

        // è¿æ¥ä¸²å£
        async function connectToSerial() {
            try {
                const baudRate = parseInt(document.getElementById('baudRate').value);
                const dataBits = parseInt(document.getElementById('dataBits').value);
                const stopBits = parseInt(document.getElementById('stopBits').value);
                const parity = document.getElementById('parity').value;

                serialPort = await navigator.serial.requestPort();
                
                await serialPort.open({
                    baudRate: baudRate,
                    dataBits: dataBits,
                    stopBits: stopBits,
                    parity: parity
                });

                isConnected = true;
                connectionStartTime = Date.now();
                communicationStartTime = Date.now();
                errorCount = 0;
                updateConnectionStatus(true);
                showSuccess('ä¸²å£è¿æ¥æˆåŠŸï¼');
                
                // å¼€å§‹è¯»å–æ•°æ®
                reader = serialPort.readable.getReader();
                writer = serialPort.writable.getWriter();
                
                readSerialData();
                
            } catch (error) {
                console.error('è¿æ¥å¤±è´¥:', error);
                showError('è¿æ¥å¤±è´¥: ' + error.message);
            }
        }

        // æ–­å¼€ä¸²å£è¿æ¥
        async function disconnectFromSerial() {
            try {
                if (reader) {
                    await reader.cancel();
                    await reader.releaseLock();
                    reader = null;
                }
                
                if (writer) {
                    await writer.releaseLock();
                    writer = null;
                }
                
                if (serialPort) {
                    await serialPort.close();
                    serialPort = null;
                }
                
                isConnected = false;
                connectionStartTime = null;
                communicationStartTime = null;
                lastDataTime = null;
                updateConnectionStatus(false);
                showSuccess('ä¸²å£å·²æ–­å¼€è¿æ¥');
                
            } catch (error) {
                console.error('æ–­å¼€è¿æ¥å¤±è´¥:', error);
                showError('æ–­å¼€è¿æ¥å¤±è´¥: ' + error.message);
            }
        }

        // è¯»å–ä¸²å£æ•°æ®
        async function readSerialData() {
            try {
                while (isConnected && reader) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    const textDecoder = new TextDecoder();
                    const text = textDecoder.decode(value);
                    
                    rxByteCount += value.length;
                    lastDataTime = Date.now();
                    updateStats();
                    
                    displayReceivedData(text);
                }
            } catch (error) {
                console.error('è¯»å–æ•°æ®å¤±è´¥:', error);
                if (isConnected) {
                    errorCount++;
                    updateStats();
                    showError('è¯»å–æ•°æ®å¤±è´¥: ' + error.message);
                }
            }
        }

        // å‘é€ä¸²å£æ•°æ®
        async function sendSerialData() {
            if (!isConnected || !writer) {
                showError('è¯·å…ˆè¿æ¥ä¸²å£è®¾å¤‡');
                return;
            }

            try {
                let data = sendData.value;
                
                if (!data.trim()) {
                    showError('è¯·è¾“å…¥è¦å‘é€çš„æ•°æ®');
                    return;
                }

                // HEX æ¨¡å¼å¤„ç†
                if (hexMode.checked) {
                    const hexData = data.replace(/\s/g, '');
                    if (!/^[0-9A-Fa-f]*$/.test(hexData)) {
                        showError('HEX æ ¼å¼æ— æ•ˆï¼Œåªèƒ½åŒ…å« 0-9 å’Œ A-F');
                        return;
                    }
                    
                    const bytes = [];
                    for (let i = 0; i < hexData.length; i += 2) {
                        bytes.push(parseInt(hexData.substr(i, 2), 16));
                    }
                    data = String.fromCharCode(...bytes);
                }

                // æ·»åŠ æ¢è¡Œç¬¦
                if (addNewline.checked) {
                    data += '\r\n';
                }

                const encoder = new TextEncoder();
                const encodedData = encoder.encode(data);
                
                await writer.write(encodedData);
                
                txByteCount += encodedData.length;
                updateStats();
                
                // æ˜¾ç¤ºå‘é€çš„æ•°æ®
                displaySentData(data);
                
                // æ·»åŠ åˆ°å†å²è®°å½•
                addToSendHistory(sendData.value);
                
                // æ¸…ç©ºè¾“å…¥æ¡†
                if (!cyclicSend.checked) {
                    sendData.value = '';
                    updateCharCount();
                }
                
            } catch (error) {
                console.error('å‘é€æ•°æ®å¤±è´¥:', error);
                errorCount++;
                updateStats();
                showError('å‘é€æ•°æ®å¤±è´¥: ' + error.message);
            }
        }

        // æ˜¾ç¤ºæ¥æ”¶åˆ°çš„æ•°æ®
        function displayReceivedData(data) {
            if (isReceivePaused) {
                return;
            }
            
            const timestamp = showTimestamp.checked ? `[${new Date().toLocaleTimeString()}] ` : '';
            
            // å°†æ•°æ®æ·»åŠ åˆ°ç¼“å†²åŒº
            receiveBuffer.push({
                timestamp: new Date(),
                data: data,
                type: 'receive'
            });
            
            // ç®¡ç†ç¼“å†²åŒºå¤§å°
            if (receiveBuffer.length > maxBufferSize) {
                receiveBuffer = receiveBuffer.slice(-maxBufferSize);
            }
            
            // æ ¼å¼åŒ–æ•°æ®æ˜¾ç¤º
            let displayData = data;
            if (receiveHexMode.checked) {
                displayData = stringToHex(data);
            }
            
            const content = `${timestamp}â† ${displayData}\n`;
            
            dataDisplay.textContent += content;
            dataDisplay.classList.add('has-data');
            
            if (autoScroll.checked) {
                dataDisplay.scrollTop = dataDisplay.scrollHeight;
            }
        }

        // æ˜¾ç¤ºå‘é€çš„æ•°æ®
        function displaySentData(data) {
            const timestamp = showTimestamp.checked ? `[${new Date().toLocaleTimeString()}] ` : '';
            
            // å°†æ•°æ®æ·»åŠ åˆ°ç¼“å†²åŒº
            receiveBuffer.push({
                timestamp: new Date(),
                data: data,
                type: 'send'
            });
            
            // æ ¼å¼åŒ–æ•°æ®æ˜¾ç¤º
            let displayData = data;
            if (receiveHexMode.checked) {
                displayData = stringToHex(data);
            }
            
            const content = `${timestamp}â†’ ${displayData}\n`;
            
            dataDisplay.textContent += content;
            dataDisplay.classList.add('has-data');
            
            if (autoScroll.checked) {
                dataDisplay.scrollTop = dataDisplay.scrollHeight;
            }
        }

        // æ¸…ç©ºæ¥æ”¶æ•°æ®
        function clearReceivedData() {
            if (receiveBuffer.length === 0) {
                showError('æ²¡æœ‰æ•°æ®å¯æ¸…é™¤');
                return;
            }
            
            showClearConfirmDialog();
        }

        // æ˜¾ç¤ºæ¸…é™¤ç¡®è®¤å¯¹è¯æ¡†
        function showClearConfirmDialog() {
            const confirmContent = `
<div style="text-align: center; padding: 16px;">
    <h4 style="margin-bottom: 16px; color: #374151;">ç¡®è®¤æ¸…é™¤æ•°æ®</h4>
    <p style="margin-bottom: 16px; color: #6B7280;">
        å³å°†æ¸…é™¤æ‰€æœ‰æ¥æ”¶å’Œå‘é€çš„æ•°æ®è®°å½•ï¼ˆå…± ${receiveBuffer.length} æ¡è®°å½•ï¼‰ã€‚
        <br><br>
        <strong>æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼</strong>
    </p>
    <div style="display: flex; justify-content: center; gap: 12px;">
        <button onclick="confirmClearData()" style="padding: 8px 24px; background: #EF4444; color: white; border: none; border-radius: 4px; cursor: pointer;">ç¡®è®¤æ¸…é™¤</button>
        <button onclick="closeModal()" style="padding: 8px 24px; background: #6B7280; color: white; border: none; border-radius: 4px; cursor: pointer;">å–æ¶ˆ</button>
    </div>
</div>
            `;
            
            showModal('ç¡®è®¤æ“ä½œ', confirmContent);
        }

        // ç¡®è®¤æ¸…é™¤æ•°æ®
        window.confirmClearData = function() {
            dataDisplay.textContent = '';
            dataDisplay.classList.remove('has-data');
            receiveBuffer = [];
            rxByteCount = 0;
            txByteCount = 0;
            errorCount = 0;
            communicationStartTime = Date.now(); // é‡ç½®é€šä¿¡å¼€å§‹æ—¶é—´
            lastDataTime = null;
            updateStats();
            
            showSuccess('æ•°æ®å·²æ¸…é™¤');
            
            // å…³é—­æ¨¡æ€æ¡†
            const modal = document.querySelector('[style*="position: fixed"]');
            if (modal) {
                document.body.removeChild(modal);
            }
        };

        // ä¿å­˜æ¥æ”¶æ•°æ®
        function saveReceivedData() {
            if (receiveBuffer.length === 0) {
                showError('æ²¡æœ‰æ•°æ®å¯ä¿å­˜');
                return;
            }

            showDataExportDialog();
        }

        // æ˜¾ç¤ºæ•°æ®å¯¼å‡ºå¯¹è¯æ¡†
        function showDataExportDialog() {
            const exportContent = `
<div style="margin-bottom: 16px;">
    <h4 style="margin-bottom: 8px;">é€‰æ‹©å¯¼å‡ºæ ¼å¼:</h4>
    <div style="display: flex; flex-direction: column; gap: 8px;">
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="radio" name="exportFormat" value="txt" checked>
            <span>æ–‡æœ¬æ–‡ä»¶ (.txt) - çº¯æ–‡æœ¬æ ¼å¼</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="radio" name="exportFormat" value="log">
            <span>æ—¥å¿—æ–‡ä»¶ (.log) - å¸¦æ—¶é—´æˆ³çš„æ—¥å¿—æ ¼å¼</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="radio" name="exportFormat" value="csv">
            <span>CSVæ–‡ä»¶ (.csv) - è¡¨æ ¼æ ¼å¼</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="radio" name="exportFormat" value="json">
            <span>JSONæ–‡ä»¶ (.json) - ç»“æ„åŒ–æ•°æ®æ ¼å¼</span>
        </label>
    </div>
</div>

<div style="margin-bottom: 16px;">
    <h4 style="margin-bottom: 8px;">å¯¼å‡ºé€‰é¡¹:</h4>
    <div style="display: flex; flex-direction: column; gap: 8px;">
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="includeMetadata" checked>
            <span>åŒ…å«å…ƒæ•°æ®ï¼ˆç»Ÿè®¡ä¿¡æ¯ã€é…ç½®ç­‰ï¼‰</span>
        </label>
        <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="includeTimestamp" checked>
            <span>åŒ…å«æ—¶é—´æˆ³</span>
        </label>
    </div>
</div>

<div style="text-align: center;">
    <button onclick="performDataExport()" style="padding: 8px 24px; background: #10B981; color: white; border: none; border-radius: 4px; cursor: pointer; margin-right: 8px;">å¯¼å‡º</button>
    <button onclick="closeModal()" style="padding: 8px 24px; background: #6B7280; color: white; border: none; border-radius: 4px; cursor: pointer;">å–æ¶ˆ</button>
</div>
            `;
            
            showModal('å¯¼å‡ºæ•°æ®', exportContent);
        }

        // æ‰§è¡Œæ•°æ®å¯¼å‡º
        window.performDataExport = function() {
            const selectedFormat = document.querySelector('input[name="exportFormat"]:checked').value;
            const includeMetadata = document.getElementById('includeMetadata').checked;
            const includeTimestamp = document.getElementById('includeTimestamp').checked;
            
            let exportData = '';
            let filename = `serial_log_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}`;
            let mimeType = 'text/plain';
            
            switch (selectedFormat) {
                case 'txt':
                    exportData = generateTextExport(includeTimestamp);
                    filename += '.txt';
                    mimeType = 'text/plain';
                    break;
                case 'log':
                    exportData = generateLogExport(includeTimestamp, includeMetadata);
                    filename += '.log';
                    mimeType = 'text/plain';
                    break;
                case 'csv':
                    exportData = generateCSVExport(includeTimestamp);
                    filename += '.csv';
                    mimeType = 'text/csv';
                    break;
                case 'json':
                    exportData = generateJSONExport(includeMetadata);
                    filename += '.json';
                    mimeType = 'application/json';
                    break;
            }
            
            if (includeMetadata && selectedFormat !== 'json') {
                const metadata = generateMetadata();
                exportData = metadata + '\n' + exportData;
            }
            
            // ä¸‹è½½æ–‡ä»¶
            const blob = new Blob([exportData], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showSuccess(`æ•°æ®å·²å¯¼å‡ºä¸º ${selectedFormat.toUpperCase()} æ ¼å¼`);
            
            // å…³é—­æ¨¡æ€æ¡†
            const modal = document.querySelector('[style*="position: fixed"]');
            if (modal) {
                document.body.removeChild(modal);
            }
        };

        // ç”Ÿæˆæ–‡æœ¬å¯¼å‡º
        function generateTextExport(includeTimestamp) {
            return receiveBuffer.map(item => {
                const timestamp = includeTimestamp ? `[${item.timestamp.toLocaleString()}] ` : '';
                const direction = item.type === 'receive' ? 'â†' : 'â†’';
                return `${timestamp}${direction} ${item.data}`;
            }).join('\n');
        }

        // ç”Ÿæˆæ—¥å¿—å¯¼å‡º
        function generateLogExport(includeTimestamp, includeMetadata) {
            let content = '';
            
            if (includeMetadata) {
                content += '=== ä¸²å£è°ƒè¯•ä¼šè¯æ—¥å¿— ===\n';
                content += `ä¼šè¯å¼€å§‹æ—¶é—´: ${communicationStartTime ? new Date(communicationStartTime).toLocaleString() : 'æœªçŸ¥'}\n`;
                content += `å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}\n`;
                content += `æ€»æ¥æ”¶å­—èŠ‚: ${rxByteCount}\n`;
                content += `æ€»å‘é€å­—èŠ‚: ${txByteCount}\n`;
                content += `é”™è¯¯è®¡æ•°: ${errorCount}\n`;
                content += '=================================\n\n';
            }
            
            content += receiveBuffer.map(item => {
                const timestamp = includeTimestamp ? `[${item.timestamp.toISOString()}] ` : '';
                const direction = item.type === 'receive' ? 'RX' : 'TX';
                return `${timestamp}${direction}: ${item.data}`;
            }).join('\n');
            
            return content;
        }

        // ç”ŸæˆCSVå¯¼å‡º
        function generateCSVExport(includeTimestamp) {
            let csv = includeTimestamp ? 'Timestamp,Direction,Data\n' : 'Direction,Data\n';
            
            csv += receiveBuffer.map(item => {
                const timestamp = includeTimestamp ? `"${item.timestamp.toISOString()}"` : '';
                const direction = item.type === 'receive' ? 'RX' : 'TX';
                const data = `"${item.data.replace(/"/g, '""')}"`;
                return includeTimestamp ? `${timestamp},${direction},${data}` : `${direction},${data}`;
            }).join('\n');
            
            return csv;
        }

        // ç”ŸæˆJSONå¯¼å‡º
        function generateJSONExport(includeMetadata) {
            const exportObj = {
                version: '1.0',
                exportTime: new Date().toISOString(),
                data: receiveBuffer.map(item => ({
                    timestamp: item.timestamp.toISOString(),
                    type: item.type,
                    data: item.data
                }))
            };
            
            if (includeMetadata) {
                exportObj.metadata = {
                    sessionStartTime: communicationStartTime ? new Date(communicationStartTime).toISOString() : null,
                    totalRxBytes: rxByteCount,
                    totalTxBytes: txByteCount,
                    errorCount: errorCount,
                    bufferSize: receiveBuffer.length,
                    maxBufferSize: maxBufferSize
                };
            }
            
            return JSON.stringify(exportObj, null, 2);
        }

        // ç”Ÿæˆå…ƒæ•°æ®
        function generateMetadata() {
            return `=== ä¼šè¯ä¿¡æ¯ ===
å¯¼å‡ºæ—¶é—´: ${new Date().toLocaleString()}
ä¼šè¯å¼€å§‹: ${communicationStartTime ? new Date(communicationStartTime).toLocaleString() : 'æœªçŸ¥'}
æ¥æ”¶å­—èŠ‚: ${rxByteCount}
å‘é€å­—èŠ‚: ${txByteCount}
é”™è¯¯è®¡æ•°: ${errorCount}
ç¼“å†²æ¡ç›®: ${receiveBuffer.length}/${maxBufferSize}
================`;
        }

        // æ›´æ–°è¿æ¥çŠ¶æ€
        function updateConnectionStatus(connected) {
            if (connected) {
                statusDot.classList.add('connected');
                statusText.textContent = 'å·²è¿æ¥';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
                sendBtn.disabled = false;
            } else {
                statusDot.classList.remove('connected');
                statusText.textContent = 'æœªè¿æ¥';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
                sendBtn.disabled = true;
            }
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            rxBytesSpan.textContent = rxByteCount;
            txBytesSpan.textContent = txByteCount;
            errorCountSpan.textContent = errorCount;
            bufferCountSpan.textContent = receiveBuffer.length;
            maxBufferSpan.textContent = maxBufferSize;
            
            // è®¡ç®—é€šä¿¡é€Ÿç‡
            if (communicationStartTime && lastDataTime) {
                const elapsedSeconds = (lastDataTime - communicationStartTime) / 1000;
                const totalBytes = rxByteCount + txByteCount;
                const speed = elapsedSeconds > 0 ? Math.round(totalBytes / elapsedSeconds) : 0;
                commSpeedSpan.textContent = speed;
            } else {
                commSpeedSpan.textContent = '0';
            }
        }

        // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.remove('hidden');
            successMessage.classList.add('hidden');
            setTimeout(() => {
                errorMessage.classList.add('hidden');
            }, 5000);
        }

        // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
        function showSuccess(message) {
            successMessage.textContent = message;
            successMessage.classList.remove('hidden');
            errorMessage.classList.add('hidden');
            setTimeout(() => {
                successMessage.classList.add('hidden');
            }, 3000);
        }

        // æ£€æŸ¥å·²æœ‰ä¸²å£è®¾å¤‡
        async function checkExistingPorts() {
            try {
                if ('serial' in navigator) {
                    availablePorts = await navigator.serial.getPorts();
                    updatePortList();
                    
                    // ç›‘å¬æ–°è®¾å¤‡è¿æ¥
                    navigator.serial.addEventListener('connect', (event) => {
                        console.log('ä¸²å£è®¾å¤‡å·²è¿æ¥:', event.target);
                        checkExistingPorts();
                    });
                    
                    // ç›‘å¬è®¾å¤‡æ–­å¼€
                    navigator.serial.addEventListener('disconnect', (event) => {
                        console.log('ä¸²å£è®¾å¤‡å·²æ–­å¼€:', event.target);
                        checkExistingPorts();
                        if (event.target === serialPort) {
                            disconnectFromSerial();
                        }
                    });
                }
            } catch (error) {
                console.error('æ£€æŸ¥ä¸²å£è®¾å¤‡å¤±è´¥:', error);
            }
        }

        // æ›´æ–°è®¾å¤‡åˆ—è¡¨
        function updatePortList() {
            const targetDevice = document.getElementById('targetDevice');
            
            // æ¸…ç©ºç°æœ‰é€‰é¡¹
            while (targetDevice.children.length > 1) {
                targetDevice.removeChild(targetDevice.lastChild);
            }
            
            // æ·»åŠ æ£€æµ‹åˆ°çš„è®¾å¤‡
            availablePorts.forEach((port, index) => {
                const option = document.createElement('option');
                option.value = index;
                
                // å°è¯•è·å–è®¾å¤‡ä¿¡æ¯
                const info = port.getInfo();
                let deviceName = `è®¾å¤‡ ${index + 1}`;
                
                if (info.usbVendorId && info.usbProductId) {
                    deviceName += ` (VID:${info.usbVendorId.toString(16).toUpperCase().padStart(4, '0')}, PID:${info.usbProductId.toString(16).toUpperCase().padStart(4, '0')})`;
                }
                
                option.textContent = deviceName;
                targetDevice.appendChild(option);
            });
            
            // æ›´æ–°è¿æ¥æŒ‰é’®çŠ¶æ€
            connectBtn.disabled = availablePorts.length === 0 && !('serial' in navigator);
        }

        // æ•…éšœæ’é™¤å¯¹è¯æ¡†
        function showTroubleshootDialog() {
            const diagnosticInfo = getDiagnosticInfo();
            
            const troubleshootContent = `
ğŸ”§ ä¸²å£æ•…éšœæ’é™¤å’Œè¯Šæ–­ä¿¡æ¯

ğŸ“Š ç³»ç»Ÿä¿¡æ¯:
â€¢ æµè§ˆå™¨: ${navigator.userAgent}
â€¢ Web Serial API æ”¯æŒ: ${'serial' in navigator ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}
â€¢ HTTPS è¿æ¥: ${location.protocol === 'https:' ? 'âœ… æ˜¯' : 'âŒ å¦ (éœ€è¦ HTTPS)'}

ğŸ”Œ è®¾å¤‡çŠ¶æ€:
â€¢ å·²æ£€æµ‹è®¾å¤‡æ•°é‡: ${availablePorts.length}
â€¢ å½“å‰è¿æ¥çŠ¶æ€: ${isConnected ? 'âœ… å·²è¿æ¥' : 'âŒ æœªè¿æ¥'}
â€¢ è¿æ¥æ—¶é•¿: ${connectionStartTime ? Math.floor((Date.now() - connectionStartTime) / 1000) + ' ç§’' : 'æœªè¿æ¥'}

ğŸ“ˆ é€šä¿¡ç»Ÿè®¡:
â€¢ æ¥æ”¶å­—èŠ‚æ•°: ${rxByteCount}
â€¢ å‘é€å­—èŠ‚æ•°: ${txByteCount}

ğŸ› ï¸ å¸¸è§é—®é¢˜è§£å†³æ–¹æ¡ˆ:

1. è®¾å¤‡æœªæ£€æµ‹åˆ°:
   - ç¡®ä¿è®¾å¤‡å·²æ­£ç¡®è¿æ¥åˆ°è®¡ç®—æœº
   - æ£€æŸ¥è®¾å¤‡é©±åŠ¨ç¨‹åºæ˜¯å¦å·²å®‰è£…
   - å°è¯•ä½¿ç”¨ä¸åŒçš„ USB ç«¯å£
   - é‡æ–°å¯åŠ¨æµè§ˆå™¨

2. è¿æ¥å¤±è´¥:
   - ç¡®ä¿è®¾å¤‡æœªè¢«å…¶ä»–ç¨‹åºå ç”¨
   - æ£€æŸ¥ä¸²å£å‚æ•°æ˜¯å¦æ­£ç¡®
   - å°è¯•é‡æ–°æ’æ‹”è®¾å¤‡

3. æ•°æ®ä¼ è¾“é—®é¢˜:
   - æ£€æŸ¥æ³¢ç‰¹ç‡è®¾ç½®æ˜¯å¦åŒ¹é…
   - ç¡®è®¤æ•°æ®ä½ã€åœæ­¢ä½ã€æ ¡éªŒä½é…ç½®
   - æ£€æŸ¥è®¾å¤‡æ˜¯å¦æ”¯æŒæ‰€é€‰çš„é€šä¿¡å‚æ•°

4. æƒé™é—®é¢˜:
   - ç¡®ä¿åœ¨ HTTPS ç¯å¢ƒä¸‹ä½¿ç”¨
   - å…è®¸æµè§ˆå™¨è®¿é—®ä¸²å£æƒé™
   - å°è¯•åˆ·æ–°é¡µé¢é‡æ–°æˆæƒ

ğŸ’¡ æç¤º: å¦‚æœé—®é¢˜æŒç»­å­˜åœ¨ï¼Œè¯·å°è¯•é‡å¯è®¾å¤‡å’Œæµè§ˆå™¨ã€‚
            `;
            
            // åˆ›å»ºæ¨¡æ€å¯¹è¯æ¡†
            showModal('æ•…éšœæ’é™¤', troubleshootContent);
        }

        // è·å–è¯Šæ–­ä¿¡æ¯
        function getDiagnosticInfo() {
            return {
                browserSupport: 'serial' in navigator,
                httpsConnection: location.protocol === 'https:',
                deviceCount: availablePorts.length,
                connectionStatus: isConnected,
                connectionDuration: connectionStartTime ? Date.now() - connectionStartTime : 0,
                rxBytes: rxByteCount,
                txBytes: txByteCount,
                userAgent: navigator.userAgent
            };
        }

        // æ˜¾ç¤ºæ¨¡æ€å¯¹è¯æ¡†
        function showModal(title, content) {
            // åˆ›å»ºæ¨¡æ€èƒŒæ™¯
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
            
            // åˆ›å»ºæ¨¡æ€å†…å®¹
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 24px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            `;
            
            modalContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <h3 style="margin: 0; color: #374151;">${title}</h3>
                    <button id="closeModal" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #6B7280;">Ã—</button>
                </div>
                <pre style="white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.5; color: #374151; background: #F9FAFB; padding: 16px; border-radius: 8px; overflow-x: auto;">${content}</pre>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // å…³é—­äº‹ä»¶
            function closeModal() {
                document.body.removeChild(modal);
            }
            
            document.getElementById('closeModal').addEventListener('click', closeModal);
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeModal();
                }
            });
            
            // ESC é”®å…³é—­
            document.addEventListener('keydown', function escHandler(e) {
                if (e.key === 'Escape') {
                    closeModal();
                    document.removeEventListener('keydown', escHandler);
                }
            });
        }

        // åˆ‡æ¢æ¥æ”¶æš‚åœçŠ¶æ€
        function toggleReceivePause() {
            isReceivePaused = !isReceivePaused;
            pauseReceiveBtn.textContent = isReceivePaused ? 'â–¶ï¸ æ¢å¤æ¥æ”¶' : 'â¸ï¸ æš‚åœæ¥æ”¶';
            pauseReceiveBtn.style.background = isReceivePaused ? '#10B981' : '#6B7280';
        }

        // åˆ·æ–°æ•°æ®æ˜¾ç¤º
        function refreshDataDisplay() {
            if (receiveBuffer.length === 0) {
                return;
            }
            
            dataDisplay.textContent = '';
            
            receiveBuffer.forEach(item => {
                const timestamp = showTimestamp.checked ? `[${item.timestamp.toLocaleTimeString()}] ` : '';
                const direction = item.type === 'receive' ? 'â†' : 'â†’';
                
                let displayData = item.data;
                if (receiveHexMode.checked) {
                    displayData = stringToHex(item.data);
                }
                
                const content = `${timestamp}${direction} ${displayData}\n`;
                dataDisplay.textContent += content;
            });
            
            dataDisplay.classList.add('has-data');
            if (autoScroll.checked) {
                dataDisplay.scrollTop = dataDisplay.scrollHeight;
            }
        }

        // è¿‡æ»¤æ˜¾ç¤ºçš„æ•°æ®
        function filterDisplayedData() {
            const filterText = searchFilter.value.toLowerCase();
            
            if (!filterText) {
                refreshDataDisplay();
                return;
            }
            
            dataDisplay.textContent = '';
            
            receiveBuffer.forEach(item => {
                const itemData = item.data.toLowerCase();
                if (itemData.includes(filterText)) {
                    const timestamp = showTimestamp.checked ? `[${item.timestamp.toLocaleTimeString()}] ` : '';
                    const direction = item.type === 'receive' ? 'â†' : 'â†’';
                    
                    let displayData = item.data;
                    if (receiveHexMode.checked) {
                        displayData = stringToHex(item.data);
                    }
                    
                    const content = `${timestamp}${direction} ${displayData}\n`;
                    dataDisplay.textContent += content;
                }
            });
            
            dataDisplay.classList.add('has-data');
            if (autoScroll.checked) {
                dataDisplay.scrollTop = dataDisplay.scrollHeight;
            }
        }

        // å­—ç¬¦ä¸²è½¬HEX
        function stringToHex(str) {
            let hex = '';
            for (let i = 0; i < str.length; i++) {
                const charCode = str.charCodeAt(i);
                hex += charCode.toString(16).toUpperCase().padStart(2, '0') + ' ';
            }
            return hex.trim();
        }

        // HEXè½¬å­—ç¬¦ä¸²
        function hexToString(hex) {
            let str = '';
            const hexArray = hex.replace(/\s/g, '').match(/.{1,2}/g);
            if (hexArray) {
                for (let i = 0; i < hexArray.length; i++) {
                    str += String.fromCharCode(parseInt(hexArray[i], 16));
                }
            }
            return str;
        }

        // æ›´æ–°å­—ç¬¦è®¡æ•°
        function updateCharCount() {
            charCount.textContent = sendData.value.length;
        }

        // æ·»åŠ åˆ°å‘é€å†å²
        function addToSendHistory(command) {
            if (!command.trim()) return;
            
            // é¿å…é‡å¤
            const index = sendHistory.indexOf(command);
            if (index > -1) {
                sendHistory.splice(index, 1);
            }
            
            sendHistory.unshift(command);
            
            // é™åˆ¶å†å²è®°å½•æ•°é‡
            if (sendHistory.length > maxHistorySize) {
                sendHistory = sendHistory.slice(0, maxHistorySize);
            }
            
            saveSendHistory();
        }

        // æ˜¾ç¤ºå‘é€å†å²
        function showSendHistory() {
            if (sendHistory.length === 0) {
                showError('æš‚æ— å‘é€å†å²è®°å½•');
                return;
            }
            
            const historyContent = sendHistory.map((cmd, index) => 
                `${index + 1}. ${cmd}`
            ).join('\n');
            
            showModal('å‘é€å†å²è®°å½•', historyContent);
        }

        // ä¿å­˜å‘é€å†å²åˆ°æœ¬åœ°å­˜å‚¨
        function saveSendHistory() {
            try {
                localStorage.setItem('serialDebugger_sendHistory', JSON.stringify(sendHistory));
            } catch (error) {
                console.warn('ä¿å­˜å‘é€å†å²å¤±è´¥:', error);
            }
        }

        // åŠ è½½å‘é€å†å²ä»æœ¬åœ°å­˜å‚¨
        function loadSendHistory() {
            try {
                const saved = localStorage.getItem('serialDebugger_sendHistory');
                if (saved) {
                    sendHistory = JSON.parse(saved);
                }
            } catch (error) {
                console.warn('åŠ è½½å‘é€å†å²å¤±è´¥:', error);
                sendHistory = [];
            }
        }

        // åˆ‡æ¢å¾ªç¯å‘é€
        function toggleCyclicSend() {
            if (cyclicSend.checked) {
                if (!isConnected) {
                    cyclicSend.checked = false;
                    showError('è¯·å…ˆè¿æ¥ä¸²å£è®¾å¤‡');
                    return;
                }
                startCyclicSend();
            } else {
                stopCyclicSend();
            }
        }

        // å¼€å§‹å¾ªç¯å‘é€
        function startCyclicSend() {
            const interval = parseInt(sendInterval.value);
            if (interval < 100) {
                showError('å‘é€é—´éš”ä¸èƒ½å°äº100ms');
                cyclicSend.checked = false;
                return;
            }
            
            cyclicSendTimer = setInterval(() => {
                if (isConnected && sendData.value.trim()) {
                    sendSerialData();
                } else {
                    stopCyclicSend();
                }
            }, interval);
            
            sendBtn.textContent = 'ğŸ”„ å¾ªç¯å‘é€ä¸­...';
            sendBtn.style.background = '#F59E0B';
        }

        // åœæ­¢å¾ªç¯å‘é€
        function stopCyclicSend() {
            if (cyclicSendTimer) {
                clearInterval(cyclicSendTimer);
                cyclicSendTimer = null;
            }
            cyclicSend.checked = false;
            sendBtn.textContent = 'ğŸ“¤ å‘é€';
            sendBtn.style.background = '#3B82F6';
        }

        // åˆå§‹åŒ–å¿«æ·å‘½ä»¤
        function initializeQuickCommands() {
            const quickButtonsContainer = document.querySelector('.quick-buttons');
            quickButtonsContainer.innerHTML = '';
            
            quickCommands.forEach(cmd => {
                const button = document.createElement('button');
                button.className = 'btn-quick';
                button.textContent = cmd.name;
                button.addEventListener('click', () => {
                    sendData.value = cmd.command;
                    updateCharCount();
                });
                quickButtonsContainer.appendChild(button);
            });
            
            // ç®¡ç†å‘½ä»¤æŒ‰é’®
            const manageBtn = document.createElement('button');
            manageBtn.className = 'btn-manage';
            manageBtn.textContent = 'ç®¡ç†å‘½ä»¤';
            manageBtn.addEventListener('click', showQuickCommandManager);
            quickButtonsContainer.appendChild(manageBtn);
        }

        // æ˜¾ç¤ºå¿«æ·å‘½ä»¤ç®¡ç†å™¨
        function showQuickCommandManager() {
            const managerContent = `
<div style="margin-bottom: 16px;">
    <h4 style="margin-bottom: 8px;">æ·»åŠ æ–°å‘½ä»¤:</h4>
    <div style="display: flex; gap: 8px; margin-bottom: 8px;">
        <input type="text" id="newCmdName" placeholder="å‘½ä»¤åç§°" style="padding: 6px 8px; border: 1px solid #D1D5DB; border-radius: 4px; flex: 1;">
        <input type="text" id="newCmdValue" placeholder="å‘½ä»¤å†…å®¹" style="padding: 6px 8px; border: 1px solid #D1D5DB; border-radius: 4px; flex: 2;">
        <button onclick="addQuickCommand()" style="padding: 6px 12px; background: #10B981; color: white; border: none; border-radius: 4px; cursor: pointer;">æ·»åŠ </button>
    </div>
</div>

<div>
    <h4 style="margin-bottom: 8px;">ç°æœ‰å‘½ä»¤:</h4>
    <div id="existingCommands">
        ${quickCommands.map((cmd, index) => `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid #E5E7EB;">
                <span><strong>${cmd.name}:</strong> ${cmd.command}</span>
                <button onclick="removeQuickCommand(${index})" style="padding: 2px 8px; background: #EF4444; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">åˆ é™¤</button>
            </div>
        `).join('')}
    </div>
</div>
            `;
            
            showModal('å¿«æ·å‘½ä»¤ç®¡ç†', managerContent);
        }

        // æ·»åŠ å¿«æ·å‘½ä»¤
        window.addQuickCommand = function() {
            const nameInput = document.getElementById('newCmdName');
            const valueInput = document.getElementById('newCmdValue');
            
            const name = nameInput.value.trim();
            const command = valueInput.value.trim();
            
            if (!name || !command) {
                alert('è¯·å¡«å†™å‘½ä»¤åç§°å’Œå†…å®¹');
                return;
            }
            
            quickCommands.push({ name, command });
            saveQuickCommands();
            initializeQuickCommands();
            
            nameInput.value = '';
            valueInput.value = '';
            
            // æ›´æ–°æ¨¡æ€æ¡†å†…å®¹
            document.getElementById('existingCommands').innerHTML = quickCommands.map((cmd, index) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid #E5E7EB;">
                    <span><strong>${cmd.name}:</strong> ${cmd.command}</span>
                    <button onclick="removeQuickCommand(${index})" style="padding: 2px 8px; background: #EF4444; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">åˆ é™¤</button>
                </div>
            `).join('');
        };

        // åˆ é™¤å¿«æ·å‘½ä»¤
        window.removeQuickCommand = function(index) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå¿«æ·å‘½ä»¤å—ï¼Ÿ')) {
                quickCommands.splice(index, 1);
                saveQuickCommands();
                initializeQuickCommands();
                
                // æ›´æ–°æ¨¡æ€æ¡†å†…å®¹
                document.getElementById('existingCommands').innerHTML = quickCommands.map((cmd, idx) => `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 4px 0; border-bottom: 1px solid #E5E7EB;">
                        <span><strong>${cmd.name}:</strong> ${cmd.command}</span>
                        <button onclick="removeQuickCommand(${idx})" style="padding: 2px 8px; background: #EF4444; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 12px;">åˆ é™¤</button>
                    </div>
                `).join('');
            }
        };

        // ä¿å­˜å¿«æ·å‘½ä»¤åˆ°æœ¬åœ°å­˜å‚¨
        function saveQuickCommands() {
            try {
                localStorage.setItem('serialDebugger_quickCommands', JSON.stringify(quickCommands));
            } catch (error) {
                console.warn('ä¿å­˜å¿«æ·å‘½ä»¤å¤±è´¥:', error);
            }
        }

        // ä»æœ¬åœ°å­˜å‚¨åŠ è½½å¿«æ·å‘½ä»¤
        function loadQuickCommands() {
            try {
                const saved = localStorage.getItem('serialDebugger_quickCommands');
                if (saved) {
                    quickCommands = JSON.parse(saved);
                }
            } catch (error) {
                console.warn('åŠ è½½å¿«æ·å‘½ä»¤å¤±è´¥:', error);
            }
        }
    </script>
</body>
</html>